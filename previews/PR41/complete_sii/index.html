<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementing the Complete Symbolic Indexing Interface · SymbolicIndexingInterface.jl</title><meta name="title" content="Implementing the Complete Symbolic Indexing Interface · SymbolicIndexingInterface.jl"/><meta property="og:title" content="Implementing the Complete Symbolic Indexing Interface · SymbolicIndexingInterface.jl"/><meta property="twitter:title" content="Implementing the Complete Symbolic Indexing Interface · SymbolicIndexingInterface.jl"/><meta name="description" content="Documentation for SymbolicIndexingInterface.jl."/><meta property="og:description" content="Documentation for SymbolicIndexingInterface.jl."/><meta property="twitter:description" content="Documentation for SymbolicIndexingInterface.jl."/><meta property="og:url" content="https://docs.sciml.ai/SymbolicIndexingInterface/stable/complete_sii/"/><meta property="twitter:url" content="https://docs.sciml.ai/SymbolicIndexingInterface/stable/complete_sii/"/><link rel="canonical" href="https://docs.sciml.ai/SymbolicIndexingInterface/stable/complete_sii/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SymbolicIndexingInterface.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymbolicIndexingInterface.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../usage/">Using the SciML Symbolic Indexing Interface</a></li><li><a class="tocitem" href="../simple_sii_sys/">Simple Demonstration of a Symbolic System Structure</a></li><li class="is-active"><a class="tocitem" href>Implementing the Complete Symbolic Indexing Interface</a><ul class="internal"><li><a class="tocitem" href="#Mandatory-methods"><span>Mandatory methods</span></a></li><li><a class="tocitem" href="#Optional-methods"><span>Optional methods</span></a></li><li class="toplevel"><a class="tocitem" href="#The-ParameterIndexingProxy"><span>The <code>ParameterIndexingProxy</code></span></a></li><li class="toplevel"><a class="tocitem" href="#Implementing-the-SymbolicTypeTrait-for-a-type"><span>Implementing the <code>SymbolicTypeTrait</code> for a type</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../solution_wrappers/">Defining Solution Wrapper Fallbacks</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Implementing the Complete Symbolic Indexing Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementing the Complete Symbolic Indexing Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/SymbolicIndexingInterface.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/SymbolicIndexingInterface.jl/blob/master/docs/src/complete_sii.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementing-the-Complete-Symbolic-Indexing-Interface"><a class="docs-heading-anchor" href="#Implementing-the-Complete-Symbolic-Indexing-Interface">Implementing the Complete Symbolic Indexing Interface</a><a id="Implementing-the-Complete-Symbolic-Indexing-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-Complete-Symbolic-Indexing-Interface" title="Permalink"></a></h1><p>This tutorial will show how to define the entire Symbolic Indexing Interface on an <code>ExampleSystem</code>:</p><pre><code class="language-julia hljs">struct ExampleSystem
  state_index::Dict{Symbol,Int}
  parameter_index::Dict{Symbol,Int}
  independent_variable::Union{Symbol,Nothing}
  # mapping from observed variable to Expr to calculate its value
  observed::Dict{Symbol,Expr}
end</code></pre><p>Not all the methods in the interface are required. Some only need to be implemented if a type supports specific functionality. Consider the following struct, which needs to implement the interface:</p><h2 id="Mandatory-methods"><a class="docs-heading-anchor" href="#Mandatory-methods">Mandatory methods</a><a id="Mandatory-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Mandatory-methods" title="Permalink"></a></h2><h3 id="Simple-Indexing-Functions"><a class="docs-heading-anchor" href="#Simple-Indexing-Functions">Simple Indexing Functions</a><a id="Simple-Indexing-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Indexing-Functions" title="Permalink"></a></h3><p>These are the simple functions which describe how to turn symbols into indices.</p><pre><code class="language-julia hljs">function SymbolicIndexingInterface.is_variable(sys::ExampleSystem, sym)
  haskey(sys.state_index, sym)
end

function SymbolicIndexingInterface.variable_index(sys::ExampleSystem, sym)
  get(sys.state_index, sym, nothing)
end

function SymbolicIndexingInterface.variable_symbols(sys::ExampleSystem)
  collect(keys(sys.state_index))
end

function SymbolicIndexingInterface.is_parameter(sys::ExampleSystem, sym)
  haskey(sys.parameter_index, sym)
end

function SymbolicIndexingInterface.parameter_index(sys::ExampleSystem, sym)
  get(sys.parameter_index, sym, nothing)
end

function SymbolicIndexingInterface.parameter_symbols(sys::ExampleSystem)
  collect(keys(sys.parameter_index))
end

function SymbolicIndexingInterface.is_independent_variable(sys::ExampleSystem, sym)
  # note we have to check separately for `nothing`, otherwise
  # `is_independent_variable(p, nothing)` would return `true`.
  sys.independent_variable !== nothing &amp;&amp; sym === sys.independent_variable
end

function SymbolicIndexingInterface.independent_variable_symbols(sys::ExampleSystem)
  sys.independent_variable === nothing ? [] : [sys.independent_variable]
end

function SymbolicIndexingInterface.is_time_dependent(sys::ExampleSystem)
  sys.independent_variable !== nothing
end

SymbolicIndexingInterface.constant_structure(::ExampleSystem) = true

function SymbolicIndexingInterface.all_solvable_symbols(sys::ExampleSystem)
  return vcat(
    collect(keys(sys.state_index)),
    collect(keys(sys.observed)),
  )
end

function SymbolicIndexingInterface.all_symbols(sys::ExampleSystem)
  return vcat(
    all_solvable_symbols(sys),
    collect(keys(sys.parameter_index)),
    sys.independent_variable === nothing ? Symbol[] : sys.independent_variable
  )
end</code></pre><h3 id="Observed-Equation-Handling"><a class="docs-heading-anchor" href="#Observed-Equation-Handling">Observed Equation Handling</a><a id="Observed-Equation-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Observed-Equation-Handling" title="Permalink"></a></h3><p>These are for handling symbolic expressions and generating equations which are not directly in the solution vector.</p><pre><code class="language-julia hljs">using RuntimeGeneratedFunctions
RuntimeGeneratedFunctions.init(@__MODULE__)

# this type accepts `Expr` for observed expressions involving state/parameter/observed
# variables
SymbolicIndexingInterface.is_observed(sys::ExampleSystem, sym) = sym isa Expr || sym isa Symbol &amp;&amp; haskey(sys.observed, sym)

function SymbolicIndexingInterface.observed(sys::ExampleSystem, sym::Expr)
  # generate a function with the appropriate signature
  if is_time_dependent(sys)
    fn_expr = :(
      function gen(u, p, t)
        # assign a variable for each state symbol it&#39;s value in u
        $([:($var = u[$idx]) for (var, idx) in pairs(sys.state_index)]...)
        # assign a variable for each parameter symbol it&#39;s value in p
        $([:($var = p[$idx]) for (var, idx) in pairs(sys.parameter_index)]...)
        # assign a variable for the independent variable
        $(sys.independent_variable) = t
        # return the value of the expression
        return $sym
      end
    )
  else
    fn_expr = :(
      function gen(u, p)
        # assign a variable for each state symbol it&#39;s value in u
        $([:($var = u[$idx]) for (var, idx) in pairs(sys.state_index)]...)
        # assign a variable for each parameter symbol it&#39;s value in p
        $([:($var = p[$idx]) for (var, idx) in pairs(sys.parameter_index)]...)
        # return the value of the expression
        return $sym
      end
    )
  end
  return @RuntimeGeneratedFunction(fn_expr)
end</code></pre><p>In case a type does not support such observed quantities, <code>is_observed</code> must be defined to always return <code>false</code>, and <code>observed</code> does not need to be implemented.</p><h3 id="Note-about-constant-structure"><a class="docs-heading-anchor" href="#Note-about-constant-structure">Note about constant structure</a><a id="Note-about-constant-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Note-about-constant-structure" title="Permalink"></a></h3><p>Note that the method definitions are all assuming <code>constant_structure(p) == true</code>.</p><p>In case <code>constant_structure(p) == false</code>, the following methods would change:</p><ul><li><code>constant_structure(::ExampleSystem) = false</code></li><li><code>variable_index(sys::ExampleSystem, sym)</code> would become <code>variable_index(sys::ExampleSystem, sym i)</code> where <code>i</code> is the time index at which the index of <code>sym</code> is required.</li><li><code>variable_symbols(sys::ExampleSystem)</code> would become <code>variable_symbols(sys::ExampleSystem, i)</code> where <code>i</code> is the time index at which the variable symbols are required.</li><li><code>observed(sys::ExampleSystem, sym)</code> would become <code>observed(sys::ExampleSystem, sym, i)</code> where <code>i</code> is either the time index at which the index of <code>sym</code> is required or a <code>Vector</code> of state symbols at the current time index.</li></ul><h2 id="Optional-methods"><a class="docs-heading-anchor" href="#Optional-methods">Optional methods</a><a id="Optional-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-methods" title="Permalink"></a></h2><p>Note that <code>observed</code> is optional if <code>is_observed</code> is always <code>false</code>, or the type is only responsible for identifying observed values and <code>observed</code> will always be called on a type that wraps this type. An example is <code>ModelingToolkit.AbstractSystem</code>, which can identify whether a value is observed, but cannot implement <code>observed</code> itself.</p><p>Other optional methods relate to indexing functions. If a type contains the values of parameter variables, it must implement <a href="../api/#SymbolicIndexingInterface.parameter_values"><code>parameter_values</code></a>. This allows the default definitions of <a href="../api/#SymbolicIndexingInterface.getp"><code>getp</code></a> and <a href="../api/#SymbolicIndexingInterface.setp"><code>setp</code></a> to work. While <code>setp</code> is not typically useful for solution objects, it may be useful for integrators. Typically, the default implementations for <code>getp</code> and <code>setp</code> will suffice, and manually defining them is not necessary.</p><pre><code class="language-julia hljs">function SymbolicIndexingInterface.parameter_values(sys::ExampleSystem)
  sys.p
end</code></pre><p>If a type contains the value of state variables, it can define <a href="../api/#SymbolicIndexingInterface.state_values"><code>state_values</code></a> to enable the usage of <a href="../api/#SymbolicIndexingInterface.getu"><code>getu</code></a> and <a href="../api/#SymbolicIndexingInterface.setu"><code>setu</code></a>. These methods retturn getter/ setter functions to access or update the value of a state variable (or a collection of them). If the type also supports generating <a href="../api/#SymbolicIndexingInterface.observed"><code>observed</code></a> functions, <code>getu</code> also enables returning functions to access the value of arbitrary expressions involving the system&#39;s symbols. This also requires that the type implement <a href="../api/#SymbolicIndexingInterface.parameter_values"><code>parameter_values</code></a> and <a href="../api/#SymbolicIndexingInterface.current_time"><code>current_time</code></a> (if the system is time-dependent).</p><p>Consider the following <code>ExampleIntegrator</code></p><pre><code class="language-julia hljs">mutable struct ExampleIntegrator
  u::Vector{Float64}
  p::Vector{Float64}
  t::Float64
  sys::ExampleSystem
end

# define a fallback for the interface methods
SymbolicIndexingInterface.symbolic_container(integ::ExampleIntegrator) = integ.sys
SymbolicIndexingInterface.state_values(sys::ExampleIntegrator) = sys.u
SymbolicIndexingInterface.parameter_values(sys::ExampleIntegrator) = sys.p
SymbolicIndexingInterface.current_time(sys::ExampleIntegrator) = sys.t</code></pre><p>Then the following example would work:</p><pre><code class="language-julia hljs">sys = ExampleSystem(Dict(:x =&gt; 1, :y =&gt; 2, :z =&gt; 3), Dict(:a =&gt; 1, :b =&gt; 2), :t, Dict())
integrator = ExampleIntegrator([1.0, 2.0, 3.0], [4.0, 5.0], 6.0, sys)
getx = getu(sys, :x)
getx(integrator) # 1.0

get_expr = getu(sys, :(x + y + t))
get_expr(integrator) # 13.0

setx! = setu(sys, :y)
setx!(integrator, 0.0)
getx(integrator) # 0.0</code></pre><p>In case a type stores timeseries data (such as solutions), then it must also implement the <a href="../api/#SymbolicIndexingInterface.Timeseries"><code>Timeseries</code></a> trait. The type would then return a timeseries from <a href="../api/#SymbolicIndexingInterface.state_values"><code>state_values</code></a> and <a href="../api/#SymbolicIndexingInterface.current_time"><code>current_time</code></a> and the function returned from <a href="../api/#SymbolicIndexingInterface.getu"><code>getu</code></a> would then return a timeseries as well. For example, consider the <code>ExampleSolution</code> below:</p><pre><code class="language-julia hljs">struct ExampleSolution
  u::Vector{Vector{Float64}}
  t::Vector{Float64}
  p::Vector{Float64}
  sys::ExampleSystem
end

# define a fallback for the interface methods
SymbolicIndexingInterface.symbolic_container(sol::ExampleSolution) = sol.sys
SymbolicIndexingInterface.parameter_values(sol::ExampleSolution) = sol.p
# define the trait
SymbolicIndexingInterface.is_timeseries(::Type{ExampleSolution}) = Timeseries()
# both state_values and current_time return a timeseries, which must be
# the same length
SymbolicIndexingInterface.state_values(sol::ExampleSolution) = sol.u
SymbolicIndexingInterface.current_time(sol::ExampleSolution) = sol.t</code></pre><p>Then the following example would work:</p><pre><code class="language-julia hljs"># using the same system that the ExampleIntegrator used
sol = ExampleSolution([[1.0, 2.0, 3.0], [1.5, 2.5, 3.5]], [4.0, 5.0], [6.0, 7.0], sys)
getx = getu(sys, :x)
getx(sol) # [1.0, 1.5]

get_expr = getu(sys, :(x + y + t))
get_expr(sol) # [9.0, 11.0]

get_arr = getu(sys, [:y, :(x + a)])
get_arr(sol) # [[2.0, 5.0], [2.5, 5.5]]

get_tuple = getu(sys, (:z, :(z * t)))
get_tuple(sol) # [(3.0, 18.0), (3.5, 24.5)]</code></pre><p>Note that <code>setu</code> is not designed to work for <code>Timeseries</code> objects.</p><p>If a type needs to perform some additional actions when updating the state/parameters or if it is not possible to return a mutable reference to the state/parameter vector which can directly be modified, the functions <a href="../api/#SymbolicIndexingInterface.set_state!"><code>set_state!</code></a> and/or <a href="../api/#SymbolicIndexingInterface.set_parameter!"><code>set_parameter!</code></a> can be used. For example, suppose our <code>ExampleIntegrator</code> had an additional field <code>u_modified::Bool</code> to allow it to keep track of when a discontinuity occurs and handle it appropriately. This flag needs to be set to <code>true</code> whenever the state is modified. The <code>set_state!</code> function can then be implemented as follows:</p><pre><code class="language-julia hljs">function SymbolicIndexingInterface.set_state!(integrator::ExampleIntegrator, val, idx)
  integrator.u[idx] = val
  integrator.u_modified = true
end</code></pre><h1 id="The-ParameterIndexingProxy"><a class="docs-heading-anchor" href="#The-ParameterIndexingProxy">The <code>ParameterIndexingProxy</code></a><a id="The-ParameterIndexingProxy-1"></a><a class="docs-heading-anchor-permalink" href="#The-ParameterIndexingProxy" title="Permalink"></a></h1><p><a href="../api/#SymbolicIndexingInterface.ParameterIndexingProxy"><code>ParameterIndexingProxy</code></a> is a wrapper around another type which implements the interface and allows using <a href="../api/#SymbolicIndexingInterface.getp"><code>getp</code></a> and <a href="../api/#SymbolicIndexingInterface.setp"><code>setp</code></a> to get and set parameter  values. This allows for a cleaner interface for parameter indexing. Consider the following example for <code>ExampleIntegrator</code>:</p><pre><code class="language-julia hljs">function Base.getproperty(obj::ExampleIntegrator, sym::Symbol)
  if sym === :ps
    return ParameterIndexingProxy(obj)
  else
    return getfield(obj, sym)
  end
end</code></pre><p>This enables the following API:</p><pre><code class="language-julia hljs">integrator = ExampleIntegrator([1.0, 2.0, 3.0], [4.0, 5.0], 6.0, Dict(:x =&gt; 1, :y =&gt; 2, :z =&gt; 3), Dict(:a =&gt; 1, :b =&gt; 2), :t)

integrator.ps[:a] # 4.0
getp(integrator, :a)(integrator) # functionally the same as above

integrator.ps[:b] = 3.0
setp(integrator, :b)(integrator, 3.0) # functionally the same as above</code></pre><h1 id="Implementing-the-SymbolicTypeTrait-for-a-type"><a class="docs-heading-anchor" href="#Implementing-the-SymbolicTypeTrait-for-a-type">Implementing the <code>SymbolicTypeTrait</code> for a type</a><a id="Implementing-the-SymbolicTypeTrait-for-a-type-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-SymbolicTypeTrait-for-a-type" title="Permalink"></a></h1><p>The <code>SymbolicTypeTrait</code> is used to identify values that can act as symbolic variables. It has three variants:</p><ul><li><a href="../api/#SymbolicIndexingInterface.NotSymbolic"><code>NotSymbolic</code></a> for quantities that are not symbolic. This is the default for all types.</li><li><a href="../api/#SymbolicIndexingInterface.ScalarSymbolic"><code>ScalarSymbolic</code></a> for quantities that are symbolic, and represent a single logical value.</li><li><a href="../api/#SymbolicIndexingInterface.ArraySymbolic"><code>ArraySymbolic</code></a> for quantities that are symbolic, and represent an array of values. Types implementing this trait must return an array of <code>ScalarSymbolic</code> variables of the appropriate size and dimensions when <code>collect</code>ed.</li></ul><p>The trait is implemented through the <a href="../api/#SymbolicIndexingInterface.symbolic_type"><code>symbolic_type</code></a> function. Consider the following example types:</p><pre><code class="language-julia hljs">struct MySym
  name::Symbol
end

struct MySymArr{N}
  name::Symbol
  size::NTuple{N,Int}
end</code></pre><p>They must implement the following functions:</p><pre><code class="language-julia hljs">SymbolicIndexingInterface.symbolic_type(::Type{MySym}) = ScalarSymbolic()
SymbolicIndexingInterface.hasname(::MySym) = true
SymbolicIndexingInterface.getname(sym::MySym) = sym.name

SymbolicIndexingInterface.symbolic_type(::Type{&lt;:MySymArr}) = ArraySymbolic()
SymbolicIndexingInterface.hasname(::MySymArr) = true
SymbolicIndexingInterface.getname(sym::MySymArr) = sym.name
function Base.collect(sym::MySymArr)
  [
    MySym(Symbol(sym.name, :_, join(idxs, &quot;_&quot;)))
    for idxs in Iterators.product(Base.OneTo.(sym.size)...)
  ]
end</code></pre><p><a href="../api/#SymbolicIndexingInterface.hasname"><code>hasname</code></a> is not required to always be <code>true</code> for symbolic types. For example, <code>Symbolics.Num</code> returns <code>false</code> whenever the wrapped value is a number, or an expression.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simple_sii_sys/">« Simple Demonstration of a Symbolic System Structure</a><a class="docs-footer-nextpage" href="../solution_wrappers/">Defining Solution Wrapper Fallbacks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 30 January 2024 06:50">Tuesday 30 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
