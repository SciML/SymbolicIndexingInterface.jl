var documenterSearchIndex = {"docs":
[{"location":"complete_sii/#Implementing-the-Complete-Symbolic-Indexing-Interface","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"","category":"section"},{"location":"complete_sii/#Index-Provider-Interface","page":"Implementing the Complete Symbolic Indexing Interface","title":"Index Provider Interface","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"This tutorial will show how to define the entire Symbolic Indexing Interface on an ExampleSystem:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"struct ExampleSystem\n  state_index::Dict{Symbol,Int}\n  parameter_index::Dict{Symbol,Int}\n  independent_variable::Union{Symbol,Nothing}\n  defaults::Dict{Symbol, Float64}\n  # mapping from observed variable to Expr to calculate its value\n  observed::Dict{Symbol,Expr}\nend","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Not all the methods in the interface are required. Some only need to be implemented if a type supports specific functionality. Consider the following struct, which needs to implement the interface:","category":"page"},{"location":"complete_sii/#Mandatory-methods","page":"Implementing the Complete Symbolic Indexing Interface","title":"Mandatory methods","text":"","category":"section"},{"location":"complete_sii/#Simple-Indexing-Functions","page":"Implementing the Complete Symbolic Indexing Interface","title":"Simple Indexing Functions","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"These are the simple functions which describe how to turn symbols into indices.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"function SymbolicIndexingInterface.is_variable(sys::ExampleSystem, sym)\n  haskey(sys.state_index, sym)\nend\n\nfunction SymbolicIndexingInterface.variable_index(sys::ExampleSystem, sym)\n  get(sys.state_index, sym, nothing)\nend\n\nfunction SymbolicIndexingInterface.variable_symbols(sys::ExampleSystem)\n  collect(keys(sys.state_index))\nend\n\nfunction SymbolicIndexingInterface.is_parameter(sys::ExampleSystem, sym)\n  haskey(sys.parameter_index, sym)\nend\n\nfunction SymbolicIndexingInterface.parameter_index(sys::ExampleSystem, sym)\n  get(sys.parameter_index, sym, nothing)\nend\n\nfunction SymbolicIndexingInterface.parameter_symbols(sys::ExampleSystem)\n  collect(keys(sys.parameter_index))\nend\n\nfunction SymbolicIndexingInterface.is_independent_variable(sys::ExampleSystem, sym)\n  # note we have to check separately for `nothing`, otherwise\n  # `is_independent_variable(p, nothing)` would return `true`.\n  sys.independent_variable !== nothing && sym === sys.independent_variable\nend\n\nfunction SymbolicIndexingInterface.independent_variable_symbols(sys::ExampleSystem)\n  sys.independent_variable === nothing ? [] : [sys.independent_variable]\nend\n\nfunction SymbolicIndexingInterface.is_time_dependent(sys::ExampleSystem)\n  sys.independent_variable !== nothing\nend\n\nSymbolicIndexingInterface.constant_structure(::ExampleSystem) = true\n\nfunction SymbolicIndexingInterface.all_solvable_symbols(sys::ExampleSystem)\n  return vcat(\n    collect(keys(sys.state_index)),\n    collect(keys(sys.observed)),\n  )\nend\n\nfunction SymbolicIndexingInterface.all_symbols(sys::ExampleSystem)\n  return vcat(\n    all_solvable_symbols(sys),\n    collect(keys(sys.parameter_index)),\n    sys.independent_variable === nothing ? Symbol[] : sys.independent_variable\n  )\nend\n\nfunction SymbolicIndexingInterface.default_values(sys::ExampleSystem)\n  return sys.defaults\nend","category":"page"},{"location":"complete_sii/#Observed-Equation-Handling","page":"Implementing the Complete Symbolic Indexing Interface","title":"Observed Equation Handling","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"These are for handling symbolic expressions and generating equations which are not directly in the solution vector.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"using RuntimeGeneratedFunctions\nRuntimeGeneratedFunctions.init(@__MODULE__)\n\n# this type accepts `Expr` for observed expressions involving state/parameter/observed\n# variables\nSymbolicIndexingInterface.is_observed(sys::ExampleSystem, sym) = sym isa Expr || sym isa Symbol && haskey(sys.observed, sym)\n\nfunction SymbolicIndexingInterface.observed(sys::ExampleSystem, sym::Expr)\n  # generate a function with the appropriate signature\n  if is_time_dependent(sys)\n    fn_expr = :(\n      function gen(u, p, t)\n        # assign a variable for each state symbol it's value in u\n        $([:($var = u[$idx]) for (var, idx) in pairs(sys.state_index)]...)\n        # assign a variable for each parameter symbol it's value in p\n        $([:($var = p[$idx]) for (var, idx) in pairs(sys.parameter_index)]...)\n        # assign a variable for the independent variable\n        $(sys.independent_variable) = t\n        # return the value of the expression\n        return $sym\n      end\n    )\n  else\n    fn_expr = :(\n      function gen(u, p)\n        # assign a variable for each state symbol it's value in u\n        $([:($var = u[$idx]) for (var, idx) in pairs(sys.state_index)]...)\n        # assign a variable for each parameter symbol it's value in p\n        $([:($var = p[$idx]) for (var, idx) in pairs(sys.parameter_index)]...)\n        # return the value of the expression\n        return $sym\n      end\n    )\n  end\n  return @RuntimeGeneratedFunction(fn_expr)\nend","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"In case a type does not support such observed quantities, is_observed must be defined to always return false, and observed does not need to be implemented.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"The same process can be followed for parameter_observed. In-place versions can also be implemented for parameter_observed.","category":"page"},{"location":"complete_sii/#Note-about-constant-structure","page":"Implementing the Complete Symbolic Indexing Interface","title":"Note about constant structure","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Note that the method definitions are all assuming constant_structure(p) == true.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"In case constant_structure(p) == false, the following methods would change:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"constant_structure(::ExampleSystem) = false\nvariable_index(sys::ExampleSystem, sym) would become variable_index(sys::ExampleSystem, sym i) where i is the time index at which the index of sym is required.\nvariable_symbols(sys::ExampleSystem) would become variable_symbols(sys::ExampleSystem, i) where i is the time index at which the variable symbols are required.\nobserved(sys::ExampleSystem, sym) would become observed(sys::ExampleSystem, sym, i) where i is either the time index at which the index of sym is required or a Vector of state symbols at the current time index.","category":"page"},{"location":"complete_sii/#Optional-methods","page":"Implementing the Complete Symbolic Indexing Interface","title":"Optional methods","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Note that observed is optional if is_observed is always false, or the type is only responsible for identifying observed values and observed will always be called on a type that wraps this type. An example is ModelingToolkit.AbstractSystem, which can identify whether a value is observed, but cannot implement observed itself.","category":"page"},{"location":"complete_sii/#Value-Provider-Interface","page":"Implementing the Complete Symbolic Indexing Interface","title":"Value Provider Interface","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Other interface methods relate to indexing functions. If a type contains the values of parameter variables, it must implement parameter_values. This allows the default definitions of getp and setp to work. While setp is not typically useful for solution objects, it may be useful for integrators. Typically, the default implementations for getp and setp will suffice, and manually defining them is not necessary.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"function SymbolicIndexingInterface.parameter_values(sys::ExampleSystem)\n  sys.p\nend","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"If a type contains the value of state variables, it can define state_values to enable the usage of getsym and setsym. These methods retturn getter/ setter functions to access or update the value of a state variable (or a collection of them). If the type also supports generating observed functions, getsym also enables returning functions to access the value of arbitrary expressions involving the system's symbols. This also requires that the type implement parameter_values and current_time (if the system is time-dependent).","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Consider the following ExampleIntegrator","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"mutable struct ExampleIntegrator\n  u::Vector{Float64}\n  p::Vector{Float64}\n  t::Float64\n  sys::ExampleSystem\nend\n\n# define a fallback for the interface methods\nSymbolicIndexingInterface.symbolic_container(integ::ExampleIntegrator) = integ.sys\nSymbolicIndexingInterface.state_values(sys::ExampleIntegrator) = sys.u\nSymbolicIndexingInterface.parameter_values(sys::ExampleIntegrator) = sys.p\nSymbolicIndexingInterface.current_time(sys::ExampleIntegrator) = sys.t","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Then the following example would work:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"sys = ExampleSystem(Dict(:x => 1, :y => 2, :z => 3), Dict(:a => 1, :b => 2), :t, Dict())\nintegrator = ExampleIntegrator([1.0, 2.0, 3.0], [4.0, 5.0], 6.0, sys)\ngetx = getsym(sys, :x)\ngetx(integrator) # 1.0\n\nget_expr = getsym(sys, :(x + y + t))\nget_expr(integrator) # 13.0\n\nsetx! = setsym(sys, :y)\nsetx!(integrator, 0.0)\ngetx(integrator) # 0.0","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"In case a type stores timeseries data (such as solutions), then it must also implement the Timeseries trait. The type would then return a timeseries from state_values and current_time and the function returned from getsym would then return a timeseries as well. For example, consider the ExampleSolution below:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"struct ExampleSolution\n  u::Vector{Vector{Float64}}\n  t::Vector{Float64}\n  p::Vector{Float64}\n  sys::ExampleSystem\nend\n\n# define a fallback for the interface methods\nSymbolicIndexingInterface.symbolic_container(sol::ExampleSolution) = sol.sys\nSymbolicIndexingInterface.parameter_values(sol::ExampleSolution) = sol.p\n# define the trait\nSymbolicIndexingInterface.is_timeseries(::Type{ExampleSolution}) = Timeseries()\n# both state_values and current_time return a timeseries, which must be\n# the same length\nSymbolicIndexingInterface.state_values(sol::ExampleSolution) = sol.u\nSymbolicIndexingInterface.current_time(sol::ExampleSolution) = sol.t","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Then the following example would work:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"# using the same system that the ExampleIntegrator used\nsol = ExampleSolution([[1.0, 2.0, 3.0], [1.5, 2.5, 3.5]], [4.0, 5.0], [6.0, 7.0], sys)\ngetx = getsym(sys, :x)\ngetx(sol) # [1.0, 1.5]\n\nget_expr = getsym(sys, :(x + y + t))\nget_expr(sol) # [9.0, 11.0]\n\nget_arr = getsym(sys, [:y, :(x + a)])\nget_arr(sol) # [[2.0, 5.0], [2.5, 5.5]]\n\nget_tuple = getsym(sys, (:z, :(z * t)))\nget_tuple(sol) # [(3.0, 18.0), (3.5, 24.5)]","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Note that setsym is not designed to work for Timeseries objects.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"If a type needs to perform some additional actions when updating the state/parameters or if it is not possible to return a mutable reference to the state/parameter vector which can directly be modified, the functions set_state! and/or set_parameter! can be used. For example, suppose our ExampleIntegrator had an additional field u_modified::Bool to allow it to keep track of when a discontinuity occurs and handle it appropriately. This flag needs to be set to true whenever the state is modified. The set_state! function can then be implemented as follows:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"function SymbolicIndexingInterface.set_state!(integrator::ExampleIntegrator, val, idx)\n  integrator.u[idx] = val\n  integrator.u_modified = true\nend","category":"page"},{"location":"complete_sii/#Using-finalize_parameters_hook!","page":"Implementing the Complete Symbolic Indexing Interface","title":"Using finalize_parameters_hook!","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"The function finalize_parameters_hook! is called exactly once every time the function returned by setp is called. This allows performing any additional bookkeeping required when parameter values are updated. set_parameter! also allows performing similar functionality, but is called for every parameter that is updated, instead of just once. Thus, finalize_parameters_hook! is better for expensive computations that can be performed for a bulk parameter update.","category":"page"},{"location":"complete_sii/#The-ParameterIndexingProxy","page":"Implementing the Complete Symbolic Indexing Interface","title":"The ParameterIndexingProxy","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"ParameterIndexingProxy is a wrapper around another type which implements the interface and allows using getp and setp to get and set parameter  values. This allows for a cleaner interface for parameter indexing. Consider the following example for ExampleIntegrator:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"function Base.getproperty(obj::ExampleIntegrator, sym::Symbol)\n  if sym === :ps\n    return ParameterIndexingProxy(obj)\n  else\n    return getfield(obj, sym)\n  end\nend","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"This enables the following API:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"integrator = ExampleIntegrator([1.0, 2.0, 3.0], [4.0, 5.0], 6.0, Dict(:x => 1, :y => 2, :z => 3), Dict(:a => 1, :b => 2), :t)\n\nintegrator.ps[:a] # 4.0\ngetp(integrator, :a)(integrator) # functionally the same as above\n\nintegrator.ps[:b] = 3.0\nsetp(integrator, :b)(integrator, 3.0) # functionally the same as above","category":"page"},{"location":"complete_sii/#Parameter-Timeseries","page":"Implementing the Complete Symbolic Indexing Interface","title":"Parameter Timeseries","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"If a solution object includes modified parameter values (such as through callbacks) during the simulation, it must implement several additional functions for correct functioning of getsym and getp. ParameterTimeseriesCollection helps in implementing parameter timeseries objects. The following mockup gives an example of correct implementation of these functions and the indexing syntax they enable.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"using SymbolicIndexingInterface\n\n# First, we must implement a parameter object that knows where the parameters in\n# each parameter timeseries are stored\nstruct MyParameterObject\n    p::Vector{Float64}\n    disc_idxs::Vector{Vector{Int}}\nend\n\n# To be able to access parameter values\nSymbolicIndexingInterface.parameter_values(mpo::MyParameterObject) = mpo.p\n# Update the parameter object with new values\n# Here, we don't need the index provider but it may be necessary for other implementations\nfunction SymbolicIndexingInterface.with_updated_parameter_timeseries_values(\n      ::SymbolCache, mpo::MyParameterObject, args::Pair...)\n    for (ts_idx, val) in args\n        mpo.p[mpo.disc_idxs[ts_idx]] = val\n    end\n    return mpo\nend\n\nstruct ExampleSolution2\n    sys::SymbolCache\n    u::Vector{Vector{Float64}}\n    t::Vector{Float64}\n    p::MyParameterObject # the parameter object. Only some parameters are timeseries params\n    p_ts::ParameterTimeseriesCollection\nend\n\n# Add the `:ps` property to automatically wrap in `ParameterIndexingProxy`\nfunction Base.getproperty(fs::ExampleSolution2, s::Symbol)\n    s === :ps ? ParameterIndexingProxy(fs) : getfield(fs, s)\nend\n# Use the contained `SymbolCache` for indexing\nSymbolicIndexingInterface.symbolic_container(fs::ExampleSolution2) = fs.sys\n# State indexing methods\nSymbolicIndexingInterface.state_values(fs::ExampleSolution2) = fs.u\nSymbolicIndexingInterface.current_time(fs::ExampleSolution2) = fs.t\n# By default, `parameter_values` refers to the last value\nSymbolicIndexingInterface.parameter_values(fs::ExampleSolution2) = fs.p\nSymbolicIndexingInterface.get_parameter_timeseries_collection(fs::ExampleSolution2) = fs.p_ts\n# Mark the object as a timeseries object\nSymbolicIndexingInterface.is_timeseries(::Type{ExampleSolution2}) = Timeseries()\n# Mark the object as a parameter timeseries object\nSymbolicIndexingInterface.is_parameter_timeseries(::Type{ExampleSolution2}) = Timeseries()","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"We will also need a timeseries object which will store individual parameter timeseries. DiffEqArray in RecursiveArrayTools.jl satisfies this use case, but we will implement one manually here.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"struct MyDiffEqArray\n  t::Vector{Float64}\n  u::Vector{Vector{Float64}}\nend\n\n# Must be a timeseries object, and implement `current_time` and `state_values`\nSymbolicIndexingInterface.is_timeseries(::Type{MyDiffEqArray}) = Timeseries()\nSymbolicIndexingInterface.current_time(a::MyDiffEqArray) = a.t\nSymbolicIndexingInterface.state_values(a::MyDiffEqArray) = a.u","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Now we can create an example object and observe the new functionality. Note that sol.ps[sym, args...] is identical to getp(sol, sym)(sol, args...). In a real application, the solution object will be populated during the solve process. We manually construct the object here for demonstration.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"sys = SymbolCache(\n  [:x, :y, :z], [:a, :b, :c, :d], :t;\n  # specify that :b, :c and :d are timeseries parameters\n  # :b and :c belong to the same timeseries\n  # :d is in a different timeseries\n  timeseries_parameters = Dict(\n    :b => ParameterTimeseriesIndex(1, 1),\n    :c => ParameterTimeseriesIndex(1, 2),\n    :d => ParameterTimeseriesIndex(2, 1),\n  ))\nb_c_timeseries = MyDiffEqArray(\n  collect(0.0:0.1:1.0),\n  [[0.25i, 0.35i] for i in 1:11]\n)\nd_timeseries = MyDiffEqArray(\n  collect(0.0:0.2:1.0),\n  [[0.17i] for i in 1:6]\n)\np = MyParameterObject(\n  # parameter values at the final time\n  [4.2, b_c_timeseries.u[end]..., d_timeseries.u[end]...],\n  [[2, 3], [4]]\n)\nsol = ExampleSolution2(\n    sys,\n    [i * ones(3) for i in 1:5], # u\n    collect(0.0:0.25:1.0), # t\n    p,\n    ParameterTimeseriesCollection([b_c_timeseries, d_timeseries], deepcopy(p))\n)\nsol.ps[:a] # returns the value of non-timeseries parameter","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"sol.ps[:b] # returns the timeseries of :b","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"sol.ps[:b, 3] # index at a specific index in the parameter timeseries","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"sol.ps[:b, [3, 6, 8]] # index using arrays","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"idxs = @show rand(Bool, 11) # boolean mask for indexing\nsol.ps[:b, idxs]","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"sol.ps[[:a, :b]] # :a has the same value at all time points","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"# throws an error since :b and :d belong to different timeseries\ntry\n  sol.ps[[:b, :d]]\ncatch e\n  showerror(stdout, e)\nend","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"sol.ps[:(b + c)] # observed quantities work too","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"getsym(sol, :b)(sol) # works","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"try\n  getsym(sol, [:b, :d])(sol) # errors since :b and :d belong to different timeseries\ncatch e\n  showerror(stdout, e)\nend","category":"page"},{"location":"complete_sii/#Custom-containers","page":"Implementing the Complete Symbolic Indexing Interface","title":"Custom containers","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"A custom container object (such as ModelingToolkit.MTKParameters) should implement remake_buffer to allow creating a new buffer with updated values, possibly with different types. This is already implemented for AbstractArrays (including static arrays).","category":"page"},{"location":"complete_sii/#Implementing-the-SymbolicTypeTrait-for-a-type","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the SymbolicTypeTrait for a type","text":"","category":"section"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"The SymbolicTypeTrait is used to identify values that can act as symbolic variables. It has three variants:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"NotSymbolic for quantities that are not symbolic. This is the default for all types.\nScalarSymbolic for quantities that are symbolic, and represent a single logical value.\nArraySymbolic for quantities that are symbolic, and represent an array of values. Types implementing this trait must return an array of ScalarSymbolic variables of the appropriate size and dimensions when collected.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"The trait is implemented through the symbolic_type function. Consider the following example types:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"struct MySym\n  name::Symbol\nend\n\nstruct MySymArr{N}\n  name::Symbol\n  size::NTuple{N,Int}\nend","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"They must implement the following functions:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"SymbolicIndexingInterface.symbolic_type(::Type{MySym}) = ScalarSymbolic()\nSymbolicIndexingInterface.hasname(::MySym) = true\nSymbolicIndexingInterface.getname(sym::MySym) = sym.name\n\nSymbolicIndexingInterface.symbolic_type(::Type{<:MySymArr}) = ArraySymbolic()\nSymbolicIndexingInterface.hasname(::MySymArr) = true\nSymbolicIndexingInterface.getname(sym::MySymArr) = sym.name\nfunction Base.collect(sym::MySymArr)\n  [\n    MySym(Symbol(sym.name, :_, join(idxs, \"_\")))\n    for idxs in Iterators.product(Base.OneTo.(sym.size)...)\n  ]\nend","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"hasname is not required to always be true for symbolic types. For example, Symbolics.Num returns false whenever the wrapped value is a number, or an expression.","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Introducing a type to represent expression trees:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"struct MyExpr\n  op::Function\n  args::Vector{Union{MyExpr, MySym, MySymArr, Number, Array}}\nend","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"symbolic_evaluate can be implemented as follows:","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"function symbolic_evaluate(expr::Union{MySym, MySymArr}, syms::Dict)\n  get(syms, expr, expr)\nend\nfunction symbolic_evaluate(expr::MyExpr, syms::Dict)\n  for i in eachindex(expr.args)\n    if expr.args[i] isa Union{MySym, MySymArr, MyExpr}\n      expr.args[i] = symbolic_evaluate(expr.args[i], syms)\n    end\n  end\n  if all(x -> symbolic_type(x) === NotSymbolic(), expr.args)\n    return expr.op(expr.args...)\n  end\nend","category":"page"},{"location":"complete_sii/","page":"Implementing the Complete Symbolic Indexing Interface","title":"Implementing the Complete Symbolic Indexing Interface","text":"Note the evaluation of the operation if all of the arguments are not symbolic. This is required since symbolic_evaluate must return an evaluated value if all symbolic variables are substituted.","category":"page"},{"location":"api/#Interface-Functions","page":"API","title":"Interface Functions","text":"","category":"section"},{"location":"api/#Index-provider-interface","page":"API","title":"Index provider interface","text":"","category":"section"},{"location":"api/#Mandatory-methods","page":"API","title":"Mandatory methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"is_variable\nvariable_index\nvariable_symbols\nis_parameter\nparameter_index\nparameter_symbols\nis_independent_variable\nindependent_variable_symbols\nis_observed\ndefault_values\nis_time_dependent\nconstant_structure\nall_variable_symbols\nall_symbols\nsolvedvariables\nallvariables","category":"page"},{"location":"api/#SymbolicIndexingInterface.is_variable","page":"API","title":"SymbolicIndexingInterface.is_variable","text":"is_variable(indp, sym)\n\nCheck whether the given sym is a variable in indp.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.variable_index","page":"API","title":"SymbolicIndexingInterface.variable_index","text":"variable_index(indp, sym, [i])\n\nReturn the index of the given variable sym in indp, or nothing otherwise. If constant_structure is false, this accepts the current time index as an additional parameter i.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.variable_symbols","page":"API","title":"SymbolicIndexingInterface.variable_symbols","text":"variable_symbols(indp, [i])\n\nReturn a vector of the symbolic variables being solved for in the index provider indp. If constant_structure(sys) == false this accepts an additional parameter indicating the current time index. The returned vector should not be mutated.\n\nFor types that implement Base.getindex with symbolic indices using this interface, the shorthand valp[solvedvariables] can be used as shorthand for valp[variable_symbols(sys)]. See: solvedvariables.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.is_parameter","page":"API","title":"SymbolicIndexingInterface.is_parameter","text":"is_parameter(indp, sym)\n\nCheck whether the given sym is a parameter in indp.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.parameter_index","page":"API","title":"SymbolicIndexingInterface.parameter_index","text":"parameter_index(indp, sym)\n\nReturn the index of the given parameter sym in indp, or nothing otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.parameter_symbols","page":"API","title":"SymbolicIndexingInterface.parameter_symbols","text":"parameter_symbols(indp)\n\nReturn a vector of the symbolic parameters of the given index provider indp. The returned vector should not be mutated.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.is_independent_variable","page":"API","title":"SymbolicIndexingInterface.is_independent_variable","text":"is_independent_variable(indp, sym)\n\nCheck whether the given sym is an independent variable in indp. The returned vector should not be mutated.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.independent_variable_symbols","page":"API","title":"SymbolicIndexingInterface.independent_variable_symbols","text":"independent_variable_symbols(indp)\n\nReturn a vector of the symbolic independent variables of the given index provider indp.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.is_observed","page":"API","title":"SymbolicIndexingInterface.is_observed","text":"is_observed(indp, sym)\n\nCheck whether the given sym is an observed value in indp.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.default_values","page":"API","title":"SymbolicIndexingInterface.default_values","text":"default_values(indp)\n\nReturn a dictionary mapping symbols in the index provider to their default value, if any. This includes parameter symbols. The dictionary must be mutable.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.is_time_dependent","page":"API","title":"SymbolicIndexingInterface.is_time_dependent","text":"is_time_dependent(indp)\n\nCheck if indp has time as (one of) its independent variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.constant_structure","page":"API","title":"SymbolicIndexingInterface.constant_structure","text":"constant_structure(indp)\n\nCheck if indp has a constant structure. Constant structure index providers do not change the number of variables or parameters over time.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.all_variable_symbols","page":"API","title":"SymbolicIndexingInterface.all_variable_symbols","text":"all_variable_symbols(indp)\n\nReturn a vector of variable symbols in the system, including observed quantities.\n\nFor types that implement Base.getindex with symbolic indices using this interface, The shorthand sys[allvariables] can be used as shorthand for valp[all_variable_symbols(indp)].\n\nSee: allvariables.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.all_symbols","page":"API","title":"SymbolicIndexingInterface.all_symbols","text":"all_symbols(indp)\n\nReturn an array of all symbols in the index provider. This includes parameters and independent variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.solvedvariables","page":"API","title":"SymbolicIndexingInterface.solvedvariables","text":"const solvedvariables = SolvedVariables()\n\nThis singleton is used as a shortcut to allow indexing of all solution variables (excluding observed quantities). It has a symbolic_type of ScalarSymbolic. See: variable_symbols.\n\n\n\n\n\n","category":"constant"},{"location":"api/#SymbolicIndexingInterface.allvariables","page":"API","title":"SymbolicIndexingInterface.allvariables","text":"const allvariables = AllVariables()\n\nThis singleton is used as a shortcut to allow indexing of all solution variables (including observed quantities). It has a symbolic_type of ScalarSymbolic. See all_variable_symbols.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Optional-Methods","page":"API","title":"Optional Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"symbolic_container","category":"page"},{"location":"api/#SymbolicIndexingInterface.symbolic_container","page":"API","title":"SymbolicIndexingInterface.symbolic_container","text":"symbolic_container(indp)\n\nUsing indp, return an object that implements the index provider interface. In case indp itself implements the interface, indp can be returned as-is. All index provider interface methods fall back to calling the same method on symbolic_container(indp), so this may be used for trivial implementations of the interface that forward all calls to another object.\n\nNote that this method is optional. Thus the correct method to check for a fallback is:\n\nhasmethod(symbolic_container, Tuple{typeof(indp)}) && symbolic_container(indp) != indp\n\n\n\n\n\n","category":"function"},{"location":"api/#Observed-equation-handling","page":"API","title":"Observed equation handling","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"observed\nparameter_observed","category":"page"},{"location":"api/#SymbolicIndexingInterface.observed","page":"API","title":"SymbolicIndexingInterface.observed","text":"observed(indp, sym, [states])\n\nReturn the observed function of the given sym in indp. The returned function should have the signature (u, p) -> [values...] where u and p is the current state and parameter object, respectively. If istimedependent(indp) == true, the function should accept the current time t as its third parameter. If constant_structure(indp) == false, observed accepts a third parameter, which can either be a vector of symbols indicating the order of states or a time index, which identifies the order of states. This function does not need to be defined if is_observed always returns false. Thus, it is mandatory to always check is_observed before using this function.\n\nIf !is_markovian(indp), the returned function must have the signature (u, h, p, t) -> [values...] where h is the history function, which can be called to obtain past values of the state. The exact signature and semantics of h depend on how it is used inside the returned function. h is obtained from a value provider using get_history_function.\n\nSee also: is_time_dependent, is_markovian, constant_structure.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.parameter_observed","page":"API","title":"SymbolicIndexingInterface.parameter_observed","text":"parameter_observed(indp, sym)\n\nReturn the observed function of sym in indp. This functions similarly to observed except that u is not an argument of the returned function. For time- dependent systems, the returned function must have the signature (p, t) -> [values...]. For time-independent systems, the returned function must have the signature (p) -> [values...].\n\nBy default, this function returns nothing, indicating that the index provider does not support generating parameter observed functions.\n\n\n\n\n\n","category":"function"},{"location":"api/#Historical-index-providers","page":"API","title":"Historical index providers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"is_markovian","category":"page"},{"location":"api/#SymbolicIndexingInterface.is_markovian","page":"API","title":"SymbolicIndexingInterface.is_markovian","text":"is_markovian(indp)\n\nCheck if an index provider represents a Markovian system. Markovian systems do not require knowledge of past states to simulate. This function is only applicable to index providers for which is_time_dependent(indp) returns true.\n\nNon-Markovian index providers return observed functions with a different signature. All value providers associated with a non-markovian index provider must implement get_history_function.\n\nReturns true by default.\n\n\n\n\n\n","category":"function"},{"location":"api/#Parameter-timeseries","page":"API","title":"Parameter timeseries","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"If the index provider contains parameters that change during the course of the simulation at discrete time points, it must implement the following methods to ensure correct functioning of getsym and getp for value providers that save the parameter timeseries. Note that there can be multiple parameter timeseries, in case different parameters may change at different times.","category":"page"},{"location":"api/","page":"API","title":"API","text":"is_timeseries_parameter\ntimeseries_parameter_index\nParameterTimeseriesIndex\nget_all_timeseries_indexes\nContinuousTimeseries","category":"page"},{"location":"api/#SymbolicIndexingInterface.is_timeseries_parameter","page":"API","title":"SymbolicIndexingInterface.is_timeseries_parameter","text":"is_timeseries_parameter(indp, sym)\n\nCheck whether the given sym is a timeseries parameter in indp.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.timeseries_parameter_index","page":"API","title":"SymbolicIndexingInterface.timeseries_parameter_index","text":"timeseries_parameter_index(indp, sym)\n\nReturn the index of timeseries parameter sym in indp. Must return this index as a ParameterTimeseriesIndex object. Return nothing if sym is not a timeseries parameter in indp. Defaults to returning nothing. Respects the symbolic_container fallback for indp if present.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.ParameterTimeseriesIndex","page":"API","title":"SymbolicIndexingInterface.ParameterTimeseriesIndex","text":"struct ParameterTimeseriesIndex\nfunction ParameterTimeseriesIndex(timeseries_idx, parameter_idx)\n\nA struct storing the index of the timeseries of a timeseries parameter in a parameter timeseries object. timeseries_idx refers to an index that identifies the timeseries that the parameter belongs to. parameter_idx refers to the index of the parameter's timeseries in that timeseries object. Note that parameter_idx may be different from the object returned by parameter_index for a given parameter. The two fields in this struct are timeseries_idx and parameter_idx.\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicIndexingInterface.get_all_timeseries_indexes","page":"API","title":"SymbolicIndexingInterface.get_all_timeseries_indexes","text":"get_all_timeseries_indexes(indp, sym)\n\nReturn a Set of all unique timeseries indexes of variables in symbolic variable sym. sym may be a symbolic variable or expression, an array of symbolics, an index, or an array of indices. Continuous variables correspond to the ContinuousTimeseries timeseries index. Non-timeseries parameters do not have a timeseries index. Timeseries parameters have the same timeseries index as that returned by timeseries_parameter_index. Note that the independent variable corresponds to the ContinuousTimeseries timeseries index.\n\nAny ambiguities should be resolved in favor of variables. For example, if 1 could refer to the variable at index 1 or parameter at index 1, it should be interpreted as the variable.\n\nBy default, this function returns Set([ContinuousTimeseries()]).\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.ContinuousTimeseries","page":"API","title":"SymbolicIndexingInterface.ContinuousTimeseries","text":"struct ContinuousTimeseries end\n\nA singleton struct corresponding to the timeseries index of the continuous timeseries.\n\n\n\n\n\n","category":"type"},{"location":"api/#Value-provider-interface","page":"API","title":"Value provider interface","text":"","category":"section"},{"location":"api/#State-indexing","page":"API","title":"State indexing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Timeseries\nNotTimeseries\nis_timeseries\nstate_values\nset_state!\ncurrent_time\ngetsym\nsetsym","category":"page"},{"location":"api/#SymbolicIndexingInterface.Timeseries","page":"API","title":"SymbolicIndexingInterface.Timeseries","text":"struct Timeseries <: IsTimeseriesTrait end\n\nTrait indicating a type contains timeseries data. This affects the behaviour of functions such as state_values and current_time.\n\nSee also: NotTimeseries, is_timeseries\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicIndexingInterface.NotTimeseries","page":"API","title":"SymbolicIndexingInterface.NotTimeseries","text":"struct NotTimeseries <: IsTimeseriesTrait end\n\nTrait indicating a type does not contain timeseries data. This affects the behaviour of functions such as state_values and current_time. Note that if a type is NotTimeseries this only implies that it does not store timeseries data. It may still be time-dependent. For example, an ODEProblem only stores the initial state of a system, so it is NotTimeseries, but still time-dependent. This is the default trait variant for all types.\n\nSee also: Timeseries, is_timeseries.\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicIndexingInterface.is_timeseries","page":"API","title":"SymbolicIndexingInterface.is_timeseries","text":"is_timeseries(x) = is_timeseries(typeof(x))\nis_timeseries(::Type)\n\nGet the timeseries trait of a type. Defaults to NotTimeseries for all types. A type for which is_timeseries(T) == Timeseries() may also have a parameter timeseries. This is determined by the is_parameter_timeseries trait.\n\nSee also: Timeseries, NotTimeseries, is_parameter_timeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.state_values","page":"API","title":"SymbolicIndexingInterface.state_values","text":"state_values(valp)\nstate_values(valp, i)\n\nReturn an indexable collection containing the values of all states in the value provider p. If is_timeseries(valp) is Timeseries, return a vector of arrays, each of which contain the state values at the corresponding timestep. In this case, the two-argument version of the function can also be implemented to efficiently return the state values at timestep i. By default, the two-argument method calls state_values(valp)[i]. If i consists of multiple indices (for example, Colon, AbstractArray{Int}, AbstractArray{Bool}) specialized methods may be defined for efficiency. By default, state_values(valp, ::Colon) = state_values(valp) to avoid copying the timeseries.\n\nIf this function is called with an AbstractArray, it will return the same array.\n\nSee: is_timeseries\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.set_state!","page":"API","title":"SymbolicIndexingInterface.set_state!","text":"set_state!(valp, val, idx)\n\nSet the state at index idx to val for value provider valp. This defaults to modifying state_values(valp). If any additional bookkeeping needs to be performed or the default implementation does not work for a particular type, this method needs to be defined to enable the proper functioning of setsym.\n\nSee: state_values\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.current_time","page":"API","title":"SymbolicIndexingInterface.current_time","text":"current_time(valp)\ncurrent_time(valp, i)\n\nReturn the current time in the value provider valp. If is_timeseries(valp) is Timeseries, return the vector of timesteps at which the state value is saved. In this case, the two-argument version of the function can also be implemented to efficiently return the time at timestep i. By default, the two- argument method calls current_time(p)[i]. It is assumed that the timeseries is sorted in increasing order.\n\nIf i consists of multiple indices (for example, Colon, AbstractArray{Int}, AbstractArray{Bool}) specialized methods may be defined for efficiency. By default, current_time(valp, ::Colon) = current_time(valp) to avoid copying the timeseries.\n\nBy default, the single-argument version acts as the identity function if valp isa AbstractVector.\n\nSee: is_timeseries\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.getsym","page":"API","title":"SymbolicIndexingInterface.getsym","text":"getsym(indp, sym)\n\nReturn a function that takes a value provider and returns the value of the symbolic variable sym. If sym is not an observed quantity, the returned function can also directly be called with an array of values representing the state vector. sym can be an index into the state vector, a symbolic variable, a symbolic expression involving symbolic variables in the index provider indp, a parameter symbol, the independent variable symbol, or an array/tuple of the aforementioned. If the returned function is called with a timeseries object, it can also be given a second argument representing the index at which to return the value of sym.\n\nAt minimum, this requires that the value provider implement state_values. To support symbolic expressions, the value provider must implement observed, parameter_values and current_time.\n\nThis function typically does not need to be implemented, and has a default implementation relying on the above functions.\n\nIf the value provider is a parameter timeseries object, the same rules apply as getp. The difference here is that sym may also contain non-parameter symbols, and the values are always returned corresponding to the state timeseries.\n\n\n\n\n\ngetsym(bi::BatchedInterface)\n\nGiven a BatchedInterface composed from n index providers (and corresponding symbols), return a function which takes n corresponding value providers and returns an array of the values of the symbols in the union. The returned function can also be passed an AbstractArray of the appropriate eltype and size as its first argument, in which case the operation will populate the array in-place with the values of the symbols in the union.\n\nNote that all of the value providers passed to the function returned by getsym must satisfy is_timeseries(prob) === NotTimeseries().\n\nThe value of the ith symbol in the union (obtained through variable_symbols(bi)[i]) is obtained from the problem corresponding to the associated index provider (i.e. the value provider at index associated_systems(bi)[i]).\n\nSee also: variable_symbols, associated_systems, is_timeseries, NotTimeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.setsym","page":"API","title":"SymbolicIndexingInterface.setsym","text":"setsym(sys, sym)\n\nReturn a function that takes a value provider and a value, and sets the the state sym to that value. Note that sym can be an index, a symbolic variable, or an array/tuple of the aforementioned.\n\nRequires that the value provider implement state_values and the returned collection be a mutable reference to the state vector in the value provider. Alternatively, if this is not possible or additional actions need to be performed when updating state, set_state! can be defined. This function does not work on types for which is_timeseries is Timeseries.\n\n\n\n\n\nsetsym(bi::BatchedInterface)\n\nGiven a BatchedInterface composed from n index providers (and corresponding symbols), return a function which takes n corresponding problems and an array of the values, and updates each of the problems with the values of the corresponding symbols.\n\nNote that all of the value providers passed to the function returned by setsym must satisfy is_timeseries(prob) === NotTimeseries().\n\nNote that if any subset of the n index providers share common symbols (among those passed to BatchedInterface) then all of the corresponding value providers in the subset will be updated with the values of the common symbols.\n\nSee also: is_timeseries, NotTimeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"note: Note\ngetu and setu have been renamed to getsym and setsym respectively.","category":"page"},{"location":"api/#Historical-value-providers","page":"API","title":"Historical value providers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_history_function","category":"page"},{"location":"api/#SymbolicIndexingInterface.get_history_function","page":"API","title":"SymbolicIndexingInterface.get_history_function","text":"get_history_function(valp)\n\nReturn the history function for a value provider. This is required for all value providers associated with an index provider indp for which !is_markovian(indp).\n\nSee also: is_markovian.\n\n\n\n\n\n","category":"function"},{"location":"api/#Parameter-indexing","page":"API","title":"Parameter indexing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"parameter_values\nset_parameter!\nfinalize_parameters_hook!\ngetp\nsetp\nsetp_oop\nParameterIndexingProxy","category":"page"},{"location":"api/#SymbolicIndexingInterface.parameter_values","page":"API","title":"SymbolicIndexingInterface.parameter_values","text":"parameter_values(valp)\nparameter_values(valp, i)\n\nReturn an indexable collection containing the value of each parameter in valp. The two- argument version of this function returns the parameter value at index i. The two-argument version of this function will default to returning parameter_values(valp)[i].\n\nIf this function is called with an AbstractArray or Tuple, it will return the same array/tuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.set_parameter!","page":"API","title":"SymbolicIndexingInterface.set_parameter!","text":"set_parameter!(valp, val, idx)\n\nSet the parameter at index idx to val for value provider valp. This defaults to modifying parameter_values(valp). If any additional bookkeeping needs to be performed or the default implementation does not work for a particular type, this method needs to be defined to enable the proper functioning of setp.\n\nSee: parameter_values\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.finalize_parameters_hook!","page":"API","title":"SymbolicIndexingInterface.finalize_parameters_hook!","text":"finalize_parameters_hook!(valp, sym)\n\nThis is a callback run one for each call to the function returned by setp which can be used to update internal data structures when parameters are modified. This is in contrast to set_parameter! which is run once for each parameter that is updated.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.getp","page":"API","title":"SymbolicIndexingInterface.getp","text":"getp(indp, sym)\n\nReturn a function that takes an value provider, and returns the value of the parameter sym. The value provider has to at least store the values of parameters in the corresponding index provider. Note that sym can be an index, symbolic variable, or an array/tuple of the aforementioned.\n\nIf sym is an array/tuple of parameters, then the returned function can also be used as an in-place getter function. The first argument is the buffer (must be an AbstractArray) to which the parameter values should be written, and the second argument is the value provider.\n\nRequires that the value provider implement parameter_values. This function may not always need to be implemented, and has a default implementation for collections that implement getindex.\n\nIf the returned function is used on a timeseries object which saves parameter timeseries, it can be used to index said timeseries. The timeseries object must implement is_parameter_timeseries and get_parameter_timeseries_collection. Additionally, the parameter object must implement with_updated_parameter_timeseries_values.\n\nIf sym is a timeseries parameter, the function will return the timeseries of the parameter if the value provider is a parameter timeseries object. An additional argument can be provided to the function indicating the specific indexes in the timeseries at which to access the values. If sym is an array of parameters, the following cases apply:\n\nAll parameters are non-timeseries parameters: The function returns the value of each parameter.\nAll parameters are timeseries parameters: All the parameters must belong to the same timeseries (otherwise getp will error). The function returns the timeseries of all parameter values, and can be accessed at specific indices in the timeseries.\nA mix of timeseries and non-timeseries parameters: The function can only be used on non-timeseries objects and will return the value of each parameter at in the object.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.setp","page":"API","title":"SymbolicIndexingInterface.setp","text":"setp(indp, sym)\n\nReturn a function that takes a value provider and a value, and sets the parameter sym to that value. Note that sym can be an index, a symbolic variable, or an array/tuple of the aforementioned.\n\nRequires that the value provider implement parameter_values and the returned collection be a mutable reference to the parameter object. In case parameter_values cannot return such a mutable reference, or additional actions need to be performed when updating parameters, set_parameter! must be implemented.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.setp_oop","page":"API","title":"SymbolicIndexingInterface.setp_oop","text":"setp_oop(indp, sym)\n\nReturn a function which takes a value provider valp and a value val, and returns parameter_values(valp) with the parameters at sym set to val. This allows changing the types of values stored, and leverages remake_buffer. Note that sym can be an index, a symbolic variable, or an array/tuple of the aforementioned.\n\nRequires that the value provider implement parameter_values and remake_buffer.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.ParameterIndexingProxy","page":"API","title":"SymbolicIndexingInterface.ParameterIndexingProxy","text":"struct ParameterIndexingProxy\n\nThis struct wraps any struct implementing the value provider and index provider interfaces. It allows getindex and setindex! operations to get/set parameter values. Requires that the wrapped type support getp and setp for getting and setting parameter values respectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#Parameter-timeseries-2","page":"API","title":"Parameter timeseries","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"If a solution object saves a timeseries of parameter values that are updated during the simulation (such as by callbacks), it must implement the following methods to ensure correct functioning of getsym and getp.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Parameter timeseries support requires that the value provider store the different timeseries in a ParameterTimeseriesCollection.","category":"page"},{"location":"api/","page":"API","title":"API","text":"is_parameter_timeseries\nget_parameter_timeseries_collection\nParameterTimeseriesCollection\nwith_updated_parameter_timeseries_values","category":"page"},{"location":"api/#SymbolicIndexingInterface.is_parameter_timeseries","page":"API","title":"SymbolicIndexingInterface.is_parameter_timeseries","text":"is_parameter_timeseries(x) = is_parameter_timeseries(typeof(x))\nis_parameter_timeseries(::Type)\n\nGet the parameter timeseries trait of a type. Defaults to NotTimeseries for all types. A type for which is_parameter_timeseries(T) == Timeseries() must also have is_timeseries(T) == Timeseries().\n\nSee also: Timeseries, NotTimeseries, is_timeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.get_parameter_timeseries_collection","page":"API","title":"SymbolicIndexingInterface.get_parameter_timeseries_collection","text":"get_parameter_timeseries_collection(valp)\n\nReturn the ParameterTimeseriesCollection contained in timeseries value provider valp. Valid only for value providers where is_parameter_timeseries returns Timeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.ParameterTimeseriesCollection","page":"API","title":"SymbolicIndexingInterface.ParameterTimeseriesCollection","text":"struct ParameterTimeseriesCollection{T}\nfunction ParameterTimeseriesCollection(collection)\n\nA utility struct that helps in storing multiple parameter timeseries. It expects a collection of timseries objects (is_timeseries returns Timeseries) for each. Each of the timeseries objects should implement state_values and current_time. Effectively, the \"states\" of each contained timeseries object are the parameter values it stores the timeseries of.\n\nThe collection is expected to implement Base.eachindex, Base.iterate and Base.getindex. The indexes of the collection should agree with the timeseries indexes returned by calling timeseries_parameter_index on the corresponding index provider.\n\nThis type forwards eachindex, iterate and length to the contained collection. It implements Base.parent to allow access to the contained collection, and has the following getindex methods:\n\ngetindex(ptc::ParameterTimeseriesCollection, idx) = ptc.collection[idx].\ngetindex(::ParameterTimeseriesCollection, idx::ParameterTimeseriesIndex) returns the timeseries of the parameter referred to by idx.\ngetindex(::ParameterTimeseriesCollection, idx::ParameterTimeseriesIndex, subidx) returns the value of the parameter referred to by idx at the time index subidx.\nApart from these cases, if multiple indexes are provided the first is treated as a timeseries index, the second the time index in the timeseries, and the (optional) third the index of the parameter in an element of the timeseries.\n\nThe three-argument version of parameter_values is implemented for this type. The single-argument version of parameter_values returns the cached parameter object. This type does not implement any traits.\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicIndexingInterface.with_updated_parameter_timeseries_values","page":"API","title":"SymbolicIndexingInterface.with_updated_parameter_timeseries_values","text":"with_updated_parameter_timeseries_values(indp, params, args::Pair...)\n\nReturn an indexable collection containing the value of all parameters in params, with parameters belonging to specific timeseries updated to different values. Each element in args... contains the timeseries index as the first value, and the saved parameter values in that partition. Not all parameter timeseries have to be updated using this method. If an in-place update can be performed, it should be done and the modified params returned. This method falls back on the basis of symbolic_container(indp).\n\nNote that here params is the parameter object.\n\n\n\n\n\n","category":"function"},{"location":"api/#Batched-Queries-and-Updates","page":"API","title":"Batched Queries and Updates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"BatchedInterface\nassociated_systems\nsetsym_oop","category":"page"},{"location":"api/#SymbolicIndexingInterface.BatchedInterface","page":"API","title":"SymbolicIndexingInterface.BatchedInterface","text":"struct BatchedInterface{S <: AbstractVector, I}\nfunction BatchedInterface(indp_syms::Tuple...)\n\nA struct which stores information for batched calls to getsym or setsym. Given Tuples, where the first element of each tuple is an index provider and the second an array of symbolic variables (either states or parameters) in the index provider, BatchedInterface will compute the union of all symbols and associate each symbol with the first index provider with which it occurs.\n\nFor example, given two index providers s1 = SymbolCache([:x, :y, :z]) and s2 = SymbolCache([:y, :z, :w]), BatchedInterface((s1, [:x, :y]), (s2, [:y, :z])) will associate :x and :y with s1 and :z with s2. The information that s1 had associated symbols :x and :y and s2 had associated symbols :y and :z will also be retained internally.\n\nBatchedInterface implements variable_symbols, is_variable, variable_index to query the order of symbols in the union.\n\nSee getsym and setsym for further details.\n\nSee also: associated_systems.\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicIndexingInterface.associated_systems","page":"API","title":"SymbolicIndexingInterface.associated_systems","text":"associated_systems(bi::BatchedInterface)\n\nReturn an array of integers of the same length as variable_symbols(bi) where each value is the index of the index provider associated with the corresponding symbol in variable_symbols(bi).\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.setsym_oop","page":"API","title":"SymbolicIndexingInterface.setsym_oop","text":"setsym_oop(bi::BatchedInterface)\n\nGiven a BatchedInterface composed from n index providers (and corresponding symbols), return a function which takes n corresponding value providers and an array of values, and returns an n-tuple where each element is a 2-tuple consisting of the updated state values and parameter values of the corresponding value provider. Requires that the value provider implement state_values, parameter_values. The updates are performed out-of-place using remake_buffer.\n\nNote that all of the value providers passed to the returned function must satisfy is_timeseries(prob) === NotTimeseries().\n\nNote that if any subset of the n index providers share common symbols (among those passed to BatchedInterface) then all of the corresponding value providers in the subset will be updated with the values of the common symbols.\n\nSee also: is_timeseries, NotTimeseries.\n\n\n\n\n\n","category":"function"},{"location":"api/#Container-objects","page":"API","title":"Container objects","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"remake_buffer","category":"page"},{"location":"api/#SymbolicIndexingInterface.remake_buffer","page":"API","title":"SymbolicIndexingInterface.remake_buffer","text":"remake_buffer(indp, oldbuffer, idxs, vals)\n\nReturn a copy of the buffer oldbuffer with at (optionally symbolic) indexes idxs replaced by corresponding values from vals. Both idxs and vals must be iterables of the same length. idxs may contain symbolic variables whose index in the buffer is determined using indp. The types of values in vals may not match the types of values stored at the corresponding indexes in the buffer, in which case the type of the buffer should be promoted accordingly. In general, this method should attempt to preserve the types of values stored in vals as much as possible. Types can be promoted for type-stability, to maintain performance. The returned buffer should be of the same type (ignoring type-parameters) as oldbuffer.\n\nThis method is already implemented for oldbuffer::AbstractArray and oldbuffer::Tuple, and supports static arrays as well.\n\nThe deprecated version of this method which takes a Dict mapping symbols to values instead of idxs and vals will dispatch to the new method. In addition if no remake_buffer method exists with the new signature, it will call remake_buffer(sys, oldbuffer, Dict(idxs .=> vals)).\n\nNote that the new method signature allows idxs to be indexes, instead of requiring that they be symbolic variables. Thus, any type which implements the new method must also support indexes in idxs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Symbolic-Trait","page":"API","title":"Symbolic Trait","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ScalarSymbolic\nArraySymbolic\nNotSymbolic\nsymbolic_type\nhasname\ngetname\nsymbolic_evaluate","category":"page"},{"location":"api/#SymbolicIndexingInterface.ScalarSymbolic","page":"API","title":"SymbolicIndexingInterface.ScalarSymbolic","text":"struct ScalarSymbolic <: SymbolicTypeTrait end\n\nTrait indicating a type is a scalar symbolic variable.\n\nSee also: ArraySymbolic, NotSymbolic, symbolic_type\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicIndexingInterface.ArraySymbolic","page":"API","title":"SymbolicIndexingInterface.ArraySymbolic","text":"struct ArraySymbolic <: SymbolicTypeTrait end\n\nTrait indicating type is a symbolic array. Calling collect on a symbolic array must return an AbstractArray containing ScalarSymbolic variables for each element in the array, in the same shape as the represented array. For example, if a is a symbolic array representing a 2x2 matrix, collect(a) must return a 2x2 array of scalar symbolic variables.\n\nSee also: ScalarSymbolic, NotSymbolic, symbolic_type\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicIndexingInterface.NotSymbolic","page":"API","title":"SymbolicIndexingInterface.NotSymbolic","text":"struct NotSymbolic <: SymbolicTypeTrait end\n\nTrait indicating a type is not symbolic.\n\nSee also: ScalarSymbolic, ArraySymbolic, symbolic_type\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicIndexingInterface.symbolic_type","page":"API","title":"SymbolicIndexingInterface.symbolic_type","text":"symbolic_type(x) = symbolic_type(typeof(x))\nsymbolic_type(::Type)\n\nGet the symbolic type trait of a type. Default to NotSymbolic for all types except Symbol and Expr, both of which are ScalarSymbolic.\n\nSee also: ScalarSymbolic, ArraySymbolic, NotSymbolic\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.hasname","page":"API","title":"SymbolicIndexingInterface.hasname","text":"hasname(x)\n\nCheck whether the given symbolic variable (for which symbolic_type(x) != NotSymbolic()) has a valid name as per getname. Defaults to true for x::Symbol.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.getname","page":"API","title":"SymbolicIndexingInterface.getname","text":"getname(x)::Symbol\n\nGet the name of a symbolic variable as a Symbol. Acts as the identity function for x::Symbol.\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicIndexingInterface.symbolic_evaluate","page":"API","title":"SymbolicIndexingInterface.symbolic_evaluate","text":"symbolic_evaluate(expr, syms::Dict; kwargs...)\n\nReturn the value of symbolic expression expr where the values of variables involved are obtained from the dictionary syms. The keys of syms are symbolic variables (not expressions of variables). The values of syms can be values or symbolic expressions.\n\nThe returned value should either be a value or an expression involving symbolic variables not present as keys in syms.\n\nThe function can take additional keyword arguments to control implementation-specific behavior.\n\nThis is already implemented for  symbolic_evaluate(expr::Union{Symbol, Expr}, syms::Dict).\n\n\n\n\n\n","category":"function"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SymbolCache\nProblemState","category":"page"},{"location":"api/#SymbolicIndexingInterface.SymbolCache","page":"API","title":"SymbolicIndexingInterface.SymbolCache","text":"struct SymbolCache\nfunction SymbolCache(vars, [params, [indepvars]]; defaults = Dict(), timeseries_parameters = nothing)\n\nA struct implementing the index provider interface for a collection of variables, parameters, and independent variables. vars and params can be specified as arrays (in which case the index of a symbol is its index in the array) or AbstractDicts mapping symbols to indices. It is considered time dependent if it contains at least one independent variable.\n\nIt returns true for is_observed(::SymbolCache, sym) if sym isa Union{Expr, Array{Expr}, Tuple{Vararg{Expr}}. Functions can be generated using observed for Exprs involving variables in the SymbolCache if it has at most one independent variable.\n\ndefaults is an AbstractDict mapping variables and/or parameters to their default initial values. The default initial values can also be other variables/ parameters or expressions of them. timeseries_parameters is an AbstractDict the timeseries parameters in params to their ParameterTimeseriesIndex indexes.\n\nThe independent variable may be specified as a single symbolic variable instead of an array containing a single variable if the system has only one independent variable.\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicIndexingInterface.ProblemState","page":"API","title":"SymbolicIndexingInterface.ProblemState","text":"struct ProblemState\nfunction ProblemState(; u = nothing, p = nothing, t = nothing)\n\nA value provider struct which can be used as an argument to the function returned by getsym or setsym. It stores the state vector, parameter object and current time, and forwards calls to state_values, parameter_values, current_time, set_state!, set_parameter! to the contained objects.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Using-the-SciML-Symbolic-Indexing-Interface","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"","category":"section"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"This tutorial will cover ways to use the symbolic indexing interface for types that implement it. SciML's core types (problems, solutions, and iterator (integrator) types) all support this symbolic indexing interface which allows for domain-specific interfaces (such as ModelingToolkit, Catalyst, etc.) to seamlessly blend their symbolic languages with the types obtained from SciML. Other tutorials will focus on how users can make use of the interface for their own DSL, this tutorial will simply focus on what the user experience looks like for DSL which have set it up.","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"We recommend any DSL implementing the symbolic indexing interface to link to this tutorial as a full description of the functionality.","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"note: Note\nWhile this tutorial focuses on demonstrating the symbolic indexing interface for ODEs, note that the same functionality works across all of the other problem types, such as optimization problems, nonlinear problems, nonlinear solutions, etc.","category":"page"},{"location":"usage/#Symbolic-Indexing-of-Differential-Equation-Solutions","page":"Using the SciML Symbolic Indexing Interface","title":"Symbolic Indexing of Differential Equation Solutions","text":"","category":"section"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"Consider the following example:","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"using ModelingToolkit, OrdinaryDiffEq, SymbolicIndexingInterface, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\n\n@parameters   \n@variables x(t) y(t) z(t) w(t)\n\neqs = [D(D(x)) ~  * (y - x),\n    D(y) ~ x * ( - z) - y,\n    D(z) ~ x * y -  * z,\n    w ~ x + y + z]\n\n@mtkbuild sys = ODESystem(eqs, t)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"The system has 4 state variables, 3 parameters, and one observed variable:","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"ModelingToolkit.observed(sys)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"Solving the system,","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"u0 = [D(x) => 2.0,\n    x => 1.0,\n    y => 0.0,\n    z => 0.0]\n\np = [ => 28.0,\n     => 10.0,\n     => 8 / 3]\n\ntspan = (0.0, 100.0)\nprob = ODEProblem(sys, u0, tspan, p, jac = true)\nsol = solve(prob, Tsit5())","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"We can obtain the timeseries of any time-dependent variable using getindex","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"sol[x]","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"This also works for arrays or tuples of variables, including observed quantities and independent variables, for interpolating solutions, and plotting:","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"sol[[x, y]]","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"sol[(t, w)]","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"sol(1.3, idxs=x)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"sol(1.3, idxs=[x, w])","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"sol(1.3, idxs=[:y, :z])","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"plot(sol, idxs=x)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"If necessary, Symbols can be used to refer to variables. This is only valid for symbolic variables for which hasname returns true. The Symbol used must match the one returned by getname for the variable.","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"hasname(x)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"getname(x)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"sol[(:x, :w)]","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"Note how when indexing with an array, the returned type is a Vector{Array{Float64}}, and when using a Tuple, the returned type is Vector{Tuple{Float64, Float64}}. To obtain the value of all state variables, we can use the shorthand:","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"sol[solvedvariables] # equivalent to sol[variable_symbols(sol)]","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"This does not include the observed variable w. To include observed variables in the output, the following shorthand is used:","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"sol[allvariables] # equivalent to sol[all_variable_symbols(sol)]","category":"page"},{"location":"usage/#Evaluating-expressions","page":"Using the SciML Symbolic Indexing Interface","title":"Evaluating expressions","text":"","category":"section"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"getsym also generates functions for expressions if the object passed to it supports observed. For example:","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"getsym(prob, x + y + z)(prob)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"To evaluate this function using values other than the ones contained in prob, we need an object that supports state_values, parameter_values, current_time. SymbolicIndexingInterface provides the ProblemState type, which has trivial implementations of the above functions. We can thus do:","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"temp_state = ProblemState(; u = [0.1, 0.2, 0.3, 0.4], p = parameter_values(prob))\ngetsym(prob, x + y + z)(temp_state)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"Note that providing all of the state vector, parameter object and time may not be necessary if the function generated by observed does not access them. ModelingToolkit.jl generates functions that access the parameters regardless of whether they are used in the expression, and thus it needs to be provided to the ProblemState.","category":"page"},{"location":"usage/#Parameter-Indexing:-Getting-and-Setting-Parameter-Values","page":"Using the SciML Symbolic Indexing Interface","title":"Parameter Indexing: Getting and Setting Parameter Values","text":"","category":"section"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"Parameters cannot be obtained using this syntax, and instead require using getp and setp.","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"note: Note\nThe reason why parameters use a separate syntax is to be able to ensure type stability of the sol[x] indexing. Without separating the parameter indexing, the return type of symbolic indexing could be anything a parameter can be, which is general is not the same type as state variables!","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"_getter = getp(sys, )\n_getter(sol) # can also pass `prob`","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"Note that this also supports arrays/tuples of parameter symbols:","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"__getter = getp(sys, (, ))\n__getter(sol)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"Now suppose the system has to be solved with a different value of the parameter .","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"_setter = setp(sys, )\n_setter(prob, 3)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"The updated parameter values can be checked using parameter_values.","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"parameter_values(prob)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"When solving the new system, note that the parameter getter functions still work on the new solution object.","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"sol2 = solve(prob, Tsit5())\n_getter(sol)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"__getter(sol)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"To set the entire parameter vector at once, setp can be used (note that the order of symbols passed to setp must match the order of values in the array).","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"setp(prob, parameter_symbols(prob))(prob, [29.0, 11.0, 2.5])\nparameter_values(prob)","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"note: Note\nThese getters and setters generate high-performance functions for the specific chosen symbols or collection of symbols. Caching the getter/setter function and reusing it on other problem/solution instances can be the key to achieving good performance. Note that this caching is allowed only when the symbolic system is unchanged (it's fine for the numerical values to have changed, but not the underlying equations).","category":"page"},{"location":"usage/#Re-creating-a-buffer","page":"Using the SciML Symbolic Indexing Interface","title":"Re-creating a buffer","text":"","category":"section"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"To re-create a buffer (of unknowns or parameters) use remake_buffer. This allows changing the type of values in the buffer (for example, changing the value of a parameter from Float64 to Float32).","category":"page"},{"location":"usage/","page":"Using the SciML Symbolic Indexing Interface","title":"Using the SciML Symbolic Indexing Interface","text":"remake_buffer(sys, prob.p, Dict( => 1f0,  => 2f0,  => 3f0))","category":"page"},{"location":"simple_sii_sys/#Simple-Demonstration-of-a-Symbolic-System-Structure","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"","category":"section"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"In this tutorial we will show how to implement a system structure type for defining the symbolic indexing of a domain-specific language. This tutorial will show how the SymbolCache type is defined to take in arrays of symbols for its independent, dependent, and parameter variable names and uses that to define the symbolic indexing interface.","category":"page"},{"location":"simple_sii_sys/#Defining-the-ODE","page":"Simple Demonstration of a Symbolic System Structure","title":"Defining the ODE","text":"","category":"section"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"For this example, we will use the Robertson equations:","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"beginaligned\nfracdy_1dt = -004y + 10^4 y_2 y_3 \nfracdy_2dt = 004 y_1 - 10^4 y_2 y_3 - 3*10^7 y_2^2 \nfracdy_3dt = 3*10^7 y_2^2 \nendaligned","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"The in-place function for this ODE system can be defined as:","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"function rober!(du, u, p, t)\n    y, y, y = u\n    k, k, k = p\n    du[1] = -k * y + k * y * y\n    du[2] = k * y - k * y^2 - k * y * y\n    du[3] = k * y^2\n    nothing\nend","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"To add symbolic names for the states in this example, a SymbolCache can be created and passed as the sys keyword argument to the ODEFunction constructor, as shown below:","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"using OrdinaryDiffEq, SymbolicIndexingInterface\n\nsys = SymbolCache([:y, :y, :y])\nodefun = ODEFunction(rober!; sys = sys)\nnothing # hide","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"This is then used to create and solve the ODEProblem","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"prob = ODEProblem(odefun, [1.0, 0.0, 0.0], (0.0, 1e5), [0.04, 3e7, 1e4])\nsol = solve(prob, Rosenbrock23())","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"The solution can now be indexed symbolically:","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"sol[:y]","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"sol(1e3, idxs=:y)","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"However, we did not give names to the parameters or the independent variables. They can be specified using SymbolCache as well:","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"sys = SymbolCache([:y, :y, :y], [:k, :k, :k], :t)\nodefun = ODEFunction(rober!; sys = sys)\nprob = ODEProblem(odefun, [1.0, 0.0, 0.0], (0.0, 1e5), [0.04, 3e7, 1e4])\nsol = solve(prob, Rosenbrock23())\ngetk1 = getp(sys, :k)\n\ngetk1(prob)","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"getk1(sol)","category":"page"},{"location":"simple_sii_sys/","page":"Simple Demonstration of a Symbolic System Structure","title":"Simple Demonstration of a Symbolic System Structure","text":"sol[:t]","category":"page"},{"location":"solution_wrappers/#Defining-Solution-Wrapper-Fallbacks","page":"Defining Solution Wrapper Fallbacks","title":"Defining Solution Wrapper Fallbacks","text":"","category":"section"},{"location":"solution_wrappers/","page":"Defining Solution Wrapper Fallbacks","title":"Defining Solution Wrapper Fallbacks","text":"The simplest case is when the type contains an object that already implements the interface. All its methods can simply be forwarded to that object. To do so, SymbolicIndexingInterface.jl provides the symbolic_container method. For example,","category":"page"},{"location":"solution_wrappers/","page":"Defining Solution Wrapper Fallbacks","title":"Defining Solution Wrapper Fallbacks","text":"struct MySolutionWrapper{T<:SciMLBase.AbstractTimeseriesSolution}\n  sol::T\n  # other properties...\nend\n\nsymbolic_container(sys::MySolutionWrapper) = sys.sol","category":"page"},{"location":"solution_wrappers/","page":"Defining Solution Wrapper Fallbacks","title":"Defining Solution Wrapper Fallbacks","text":"MySolutionWrapper wraps an AbstractTimeseriesSolution which already implements the interface. Since symbolic_container will return the wrapped solution, all method calls such as is_parameter(sys::MySolutionWrapper, sym) will be forwarded to is_parameter(sys.sol, sym).","category":"page"},{"location":"solution_wrappers/","page":"Defining Solution Wrapper Fallbacks","title":"Defining Solution Wrapper Fallbacks","text":"In cases where some methods need to function differently than those of the wrapped type, they can be selectively defined. For example, suppose MySolutionWrapper does not support observed quantities. The following method can be defined (in addition to the one above):","category":"page"},{"location":"solution_wrappers/","page":"Defining Solution Wrapper Fallbacks","title":"Defining Solution Wrapper Fallbacks","text":"is_observed(sys::MySolutionWrapper, sym) = false","category":"page"},{"location":"#SymbolicIndexingInterface.jl:-Standardized-Symbolic-Indexing-of-Julia","page":"Home","title":"SymbolicIndexingInterface.jl: Standardized Symbolic Indexing of Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymbolicIndexingInterface.jl is a set of interface functions for handling containers of symbolic variables.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install SymbolicIndexingInterface.jl, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SymbolicIndexingInterface\")","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The symbolic indexing interface has 2 levels:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The user level. At the user level, a modeler or engineer simply uses terms from a domain-specific language (DSL) inside of SciML functionality and will receive the requested values. For example, if a DSL defines a symbol x, then sol[x] returns the solution value(s) for x.\nThe DSL system structure level. This is the structure which defines the symbolic indexing for a given problem/solution. DSLs can tag a constructed problem/solution with this object in order to endow the SciML tools with the ability to index symbolically according to the definitions the DSL writer wants.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nThere are a few community forums:\nthe #diffeq-bridged channel in the Julia Slack\nJuliaDiffEq on Gitter\non the Julia Discourse forums\nsee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"terminology/#Terminology","page":"Terminology","title":"Terminology","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"SymbolicIndexingInterface.jl uses various library-specific terminology throughout its documentation. This page attempts to provide comprehensive explanations of the terms used.","category":"page"},{"location":"terminology/#Indexes","page":"Terminology","title":"Indexes","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"An index is an object that defines how to extract specific data from a data structure. Indexes may be anything from integer indexes into arrays, to custom types that contain information specific to a particular data structure.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"In code samples, an index is typically denoted with the name idx or i.","category":"page"},{"location":"terminology/#Symbolic-variables","page":"Terminology","title":"Symbolic variables","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Symbolic variables are objects that represent quantities (states, parameters, time, etc.) or collections of quantities used in a numerical simulation in a more human-accessible manner. Typically the values of these quantities are stored in custom data structures and referred to using indexes that do not convey any semantic meaning to users. Symbolic variables cannot directly be used to access values from these data structures and need to be translated into indexes.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"In code samples, a symbolic variable is typically denoted with the name sym.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Symbolic variables are also sometimes referred to as \"symbolic indices\".","category":"page"},{"location":"terminology/#Index-providers","page":"Terminology","title":"Index providers","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Index providers translate symbolic variables into indexes. In general, an \"index\" can be anything from integer indexes into an array, or custom types that define how to index into complicated data structures. nothing is reserved to denote the absence of an index, in cases where the index provider is unaware of a particular symbolic variable. It cannot be used as an index. ModelingToolkit.jl systems are examples of index providers.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"In code samples, an index provider is typically denoted with the name indp.","category":"page"},{"location":"terminology/#Value-providers","page":"Terminology","title":"Value providers","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Value providers store values of symbolic variables. Given an appropriate index from an index provider, value providers return the value (or values) stored at that index. The problem, integrator and solution types in SciML are all examples of value providers. Each value provider is (directly or indirectly) associated with an index provider that defines the set of valid symbolic variables for that value provider, and the corresponding indexes.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"A value provider may not store values for all symbolic variables in the corresponding index provider. For example, a parameter object (even a plain Array storing parameter values) is a value provider specifically for the symbolic variables referring to parameters.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"In code samples, a value provider is typically denoted with the name valp.","category":"page"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"note: Note\nIt is important to note that an object may be both a value- and index- provider. For example, SciML's problem, integrator and solution types are both value- and index- providers. This allows for several syntactic improvements. The symbolic_container function is useful in defining such objects.","category":"page"},{"location":"terminology/#Timeseries-objects","page":"Terminology","title":"Timeseries objects","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Timeseries objects are value providers which implement the Timeseries variant of the is_timeseries trait.","category":"page"},{"location":"terminology/#Parameter-timeseries-objects","page":"Terminology","title":"Parameter timeseries objects","text":"","category":"section"},{"location":"terminology/","page":"Terminology","title":"Terminology","text":"Parameter timeseries objects are timeseries objects which implement the Timeseries variant of the is_parameter_timeseries trait.","category":"page"}]
}
